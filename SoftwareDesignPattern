## Architecture Styles from a Design‑Point of View

> **Tip:**  
>  • **Style** – a high‑level blueprint that answers *“how do the components talk to one another?”*  
>  • **Pattern** – a reusable solution to a specific problem (MVC, Repository, etc.) that lives inside a style.

Below is a taxonomy of the most common architectural styles you’ll encounter in modern software design, grouped by the **concern they address** (process, data, integration, deployment, etc.). For each style you’ll see a quick description, when it is typically chosen, and the most common tech stack or tools that support it.

| # | Architecture Style | Core Idea | Typical Use‑Cases | Key Advantages | Potential Pitfalls | Representative Tools / Tech |
|---|--------------------|-----------|------------------|----------------|--------------------|----------------------------|
| 1 | **Monolithic** | All functionality in a single deployable unit. | Small teams, rapid prototyping, legacy systems. | Simplicity, fast iteration, no inter‑process communication. | Hard to scale, single point of failure, long deployment cycles. | Spring Boot, .NET Core, Rails |
| 2 | **Layered (N‑tier)** | Functional layers (UI → Service → DAO → DB). | Classic enterprise apps, clear separation of concerns. | Easy to understand, modular testing. | Over‑engineering, tight coupling between layers if not disciplined. | JEE, ASP.NET MVC, Spring MVC |
| 3 | **Client‑Server / Thin‑Client** | Dedicated server(s) serve data; clients consume via API or UI. | Web apps, desktop clients, mobile backends. | Centralised control, straightforward security model. | Network latency, single server bottleneck. | REST, gRPC, GraphQL |
| 4 | **Microkernel (Plug‑in)** | Core engine + pluggable modules. | IDEs, OS kernels, modular business apps. | Extendable without recompilation, isolation. | Versioning of plugins, risk of core–module mismatch. | OSGi, Eclipse RCP, Netty extensions |
| 5 | **Microservices** | Each service owns a bounded context; services communicate over network (usually HTTP/REST or message bus). | Large, evolving systems, CI/CD pipelines, polyglot teams. | Independent deployment, fault isolation, language flexibility. | Distributed transaction complexity, network overhead, ops burden. | Docker + Kubernetes, Istio, Spring Cloud |
| 6 | **Service‑Oriented Architecture (SOA)** | Reusable services exposed via contracts (WSDL, REST). | Enterprise integration, on‑prem legacy systems. | Reusability, governance. | Heavyweight protocols, slow service contracts, coupling through a shared service bus. | Apache CXF, WSO2, MuleSoft |
| 7 | **Event‑Driven Architecture (EDA)** | Decoupled components react to events on a publish/subscribe channel. | Real‑time dashboards, IoT backends, loosely coupled workflows. | High scalability, natural async patterns, easy to add new consumers. | Event ordering guarantees, “event storming” overhead, debugging difficulty. | Kafka, RabbitMQ, Azure Event Grid |
| 8 | **Message‑Driven / Message‑Queue** | Tasks are serialized into messages that are queued and processed asynchronously. | Background jobs, batch pipelines, order processing. | Asynchronous flow, decoupling of producer/consumer. | Potential message loss if not idempotent, latency. | ActiveMQ, Amazon SQS, Kafka |
| 9 | **Saga / Orchestration** | Long‑running distributed transactions broken into compensating actions. | Order‑fulfillment, booking systems, micro‑service workflows. | Consistency without distributed ACID. | Complex orchestration logic, need for persistence. | Temporal, Zeebe, Netflix Conductor |
|10 | **Hexagonal (Ports & Adapters) / Clean / Onion** | Outer adapters plug into inner domain; business logic is isolated from frameworks. | Domain‑heavy apps, test‑first development, maintainability. | Clear separation, testable domain, easier migration. | Requires discipline to keep inner layers pure. | Spring Hexagonal, Micronaut, ASP.NET Clean Architecture |
|11 | **Event‑Sourced** | State is derived from an immutable stream of events; current state is the result of replaying the stream. | Auditable systems, finance, analytics pipelines. | Full audit trail, easy replay, time‑travel debugging. | Event schema evolution, large storage footprint, complexity of read‑models. | Axon, EventStore, Kafka |
|12 | **Command‑Query Responsibility Segregation (CQRS)** | Separate read and write models; often combined with event sourcing. | Systems with heavy read‑load or complex queries (e.g., analytics). | Optimised queries, scaling reads independently. | Duplication of data, consistency challenges. | Axon, NServiceBus, Spring Data |
|13 | **Reactive / Event‑Loop** | Non‑blocking, back‑pressure aware streams; often built on the Reactive Streams spec. | High‑throughput real‑time services, IoT, streaming pipelines. | Handles many concurrent connections, better resource utilisation. | Steep learning curve, debugging async flows can be hard. | Project Reactor, RxJava, Akka Streams, Vert.x |
|14 | **Serverless / FaaS** | Stateless functions run in response to events; billing per invocation. | Event‑driven micro‑tasks, short‑lived compute, variable load. | No server management, auto‑scaling, cost‑efficient for sporadic load. | Cold‑start latency, vendor lock‑in, statefulness requires external stores. | AWS Lambda, Azure Functions, Google Cloud Functions |
|15 | **Composable / Function‑as‑a‑Service** | Functions are first‑class building blocks that can be combined into larger workflows (e.g., AWS Step Functions). | Complex, multi‑step processes that require stateful orchestration. | Clear process definition, built‑in fault tolerance. | Overhead of state machine definition, limited to serverless‑friendly workloads. | AWS Step Functions, Azure Durable Functions |
|16 | **Event‑Driven (within a microservice)** | Services publish domain events; other services react (pub/sub) to them. | Highly decoupled integrations, real‑time dashboards, analytics. | Loose coupling, easy to add new consumers. | Event flooding, versioning of event schemas, debugging. | Kafka, NATS, Pulsar |
|17 | **Multi‑tenant / SaaS** | Shared infrastructure but tenant‑isolated data. | SaaS platforms, shared APIs. | Cost sharing, quick onboarding of new tenants. | Security boundaries, resource contention, tenant‑specific customisation. | Salesforce, Stripe, multi‑tenant DB schemas |
|18 | **Component‑Based** | Self‑contained components that can be reused or swapped (often used for UI). | Front‑end libraries, UI frameworks. | Reusability, independent release cycles. | Inconsistent API contracts, integration friction. | React Components, Vue, Web Components |

> **Quick check:**  
>  • *Need fast time‑to‑market and a single team? Monolith or layered.  
>  • *Have a rapidly evolving, large code‑base? Microservices or SOA.  
>  • *Want event‑driven real‑time flow? EDA + reactive patterns.  
>  • *Need on‑prem, strongly governed services? SOA or micro‑kernel.*

---

## 2. **Why use the Domain‑Driven Design (DDD) approach in your architecture?**

DDD is not a “new architecture” per se—it is a set of principles and patterns that help you model **complex business domains** in code. The benefits translate into multiple layers of the architecture:

| **Goal** | **DDD Value** | **Resulting Architecture** | **Typical Patterns** |
|----------|---------------|----------------------------|----------------------|
| **Model the true business problem** | Domain model captures real concepts (aggregates, entities, value objects). | Domain‑centric layers (hexagonal, clean). | Domain‑event, repository, service objects. |
| **Make the domain testable** | Business logic lives in pure, side‑effect‑free code. | Domain‑only layer; outer frameworks are adapters. | TDD, unit tests for domain. |
| **Encourage clear boundaries** | Bounded contexts isolate different areas of the domain. | Multiple bounded contexts as separate services or modules. | CQRS, EDA for inter‑bounded‑context communication. |
| **Provide an audit trail** | State is derived from events, not overwritten. | Event‑sourced systems. | Event‑source, read‑model projection. |
| **Scale reads and writes independently** | Separate read/write concerns. | CQRS or read‑model services. | Separate database schemas, query optimization. |
| **Enable real‑time reaction** | Publish events whenever something happens. | EDA, reactive streams. | Kafka, message brokers, asynchronous handlers. |
| **Facilitate continuous delivery** | Domain logic is decoupled from infrastructure. | Clean/hexagonal architecture. | Inversion of control, DI containers. |

### **When should you adopt DDD?**

1. **High domain complexity** – if your business logic is non‑trivial, multiple entities, and heavy business rules.
2. **Long‑term maintainability** – you expect the system to evolve over time and want to isolate change.
3. **Multiple developers/teams** – you need clear boundaries and governance so teams can work independently.
4. **Need for deep insight and auditability** – event sourcing gives you a natural audit trail.

### **When can you skip it?**

- **Simple CRUD apps** or where the domain logic is trivial – a CRUD‑only architecture (e.g., “CRUD‑only microservices” or “serverless CRUD”) may be more efficient.
- **Very small teams** where learning DDD’s patterns adds overhead faster than it brings benefits.
- **Performance‑critical, stateful services** where pure DDD’s separation might add latency (unless combined with caching or read‑models).

---

## 3. **Architectural options for “Domain-Driven” services**

### 3.1  Domain‑Driven + Microservices

| **Option** | **Description** | **Typical Stack** | **Pros** | **Cons** |
|-----------|-----------------|-------------------|----------|----------|
| **DDD + EDA** | Each microservice owns its domain model and publishes events. Other services react. | Spring Boot (Hexagonal) + Kafka, Akka | Loose coupling, clear event flow, scalability. | Event storming complexity, need for event schema governance. |
| **DDD + CQRS** | Separate command and query services per bounded context. | Axon framework, Spring Data, EventStore | Optimised reads, easy scaling. | Complexity of maintaining two models; consistency. |
| **DDD + Event Sourcing** | Persist state as events; read‑models projected separately. | Axon, EventStore, Kafka | Audit trail, ability to replay. | Event schema evolution; larger storage cost. |
| **DDD + Clean Architecture** | Keep domain pure; infrastructure (Spring MVC, JPA) plugs in as adapters. | Spring Hexagonal, Micronaut | Testable domain, easier migrations. | Requires discipline, can increase boilerplate. |
| **DDD + Serverless** | Domain logic runs in functions; events trigger actions. | AWS Lambda + Step Functions + DynamoDB | Pay‑per‑use, easy scaling for event bursts. | Cold starts, limited compute time, vendor lock‑in. |

### 3.2  Choosing the right mix

| **Consideration** | **Choose** | **Why** |
|-------------------|------------|---------|
| **Synchronous business flows** | DDD + Clean / Hexagonal + Spring MVC | Keeps domain pure, simple to debug. |
| **Asynchronous or real‑time flows** | DDD + EDA (Kafka) + reactive streams | Handles high concurrency, decoupled. |
| **High read‑write imbalance** | CQRS + event sourcing | Reads are fast and can scale. |
| **Short, stateless compute tasks** | Serverless + DDD + event‑driven | Minimal infrastructure, auto‑scale. |

---

## 4. **The Role of the “Business Service” and its Impact on the Architecture**

### 4.1  What is a Business Service?

A *business service* is a component that encapsulates domain logic that cannot be naturally expressed in an entity or value object. Think of it as a *Domain Service* in DDD. In a microservice, it is typically a **stateless class** that orchestrates domain objects or coordinates multiple bounded contexts.

### 4.2  Business‑Service‑Centric Architecture

| **Architecture** | **Components** | **How It Looks** | **When It Helps** |
|------------------|---------------|------------------|-------------------|
| **Microservice (CRUD‑only)** | REST API + CRUD service + repository | Simple CRUD, no domain model. | Small or simple domain. |
| **Microservice (DDD)** | Domain model + repository + domain service | Business rules in domain. | Complex domain, long‑term evolution. |
| **Microservice (Business‑Service‑only)** | A thin service layer that uses domain objects or external services but no complex DDD concepts. | Spring Service + Spring Data | Quick to implement, still separates concerns. | Harder to evolve complex domain logic. |
| **Monolithic Service (DDD)** | All domain logic in one process, possibly with bounded contexts inside. | Spring Boot + Hexagonal | Simpler deployment. | Single point of failure, scaling may be harder. |
| **Service‑Oriented (SOA)** | Business services that expose business operations as SOAP or REST endpoints. | Spring WS or Spring MVC | Legacy system integration. | Heavier protocol, more overhead. |

### 4.3  Impact on the architecture

| **Layer** | **DDD‑centric service** | **Non‑DDD** | **Effect** |
|-----------|------------------------|-------------|------------|
| **Presentation** | Thin adapter (e.g., REST controller). | Complex domain logic mixed in. | Easier to change UI/transport. |
| **Application** | Orchestrates domain services, uses DI. | Domain logic often in controllers. | Better separation, easier unit tests. |
| **Domain** | Pure business logic, immutable entities, value objects. | Often combined with persistence logic. | Evolves independently of tech. |
| **Infrastructure** | Adapters for persistence, messaging, etc. | Mixed with business logic. | Higher coupling, harder to swap tech. |

---

## 4. **Designing a microservice using the “Domain‑Driven” concept**

Let’s walk through a **step‑by‑step** approach to building a domain‑driven microservice. We’ll use **Java + Spring Boot** with **Hexagonal/clean architecture** as the skeleton and **Kafka** for event‑driving.  
Feel free to swap languages or frameworks if you’re in .NET, Go, Node, or others; the concepts remain.

### 4.1  Identify the Bounded Context

- **Domain**: *Order Processing* (customer orders, payments, shipping).
- **Entities**: `Order`, `LineItem`, `Address`, `Payment`.
- **Value Objects**: `Money`, `OrderStatus`.
- **Aggregates**: `Order` (root) encapsulates `LineItem` and `Payment`.

### 4.2  Define Domain Model (Aggregates)

```java
// Domain: OrderAggregate.java
package com.acme.orders.domain;

public class Order {
    private final OrderId id;
    private final List<LineItem> items = new ArrayList<>();
    private OrderStatus status = OrderStatus.CREATED;
    private Money total;
    private Address shippingAddress;

    public Order(OrderId id) {
        this.id = id;
    }

    public void addItem(ProductId productId, int qty) {
        // Business rule: can't add after shipped
        if (status != OrderStatus.CREATED) {
            throw new IllegalStateException("Order already finalized");
        }
        items.add(new LineItem(productId, qty));
        recalcTotal();
    }

    public void place(OrderId orderId) {
        // Additional validation...
        status = OrderStatus.PLACED;
        // Domain event will be published elsewhere
    }

    private void recalcTotal() {
        // compute total using Money objects
    }
}
```

> **Key point** – `Order` is **pure**: no persistence code, no dependency on Spring or JPA.

### 4.3  Domain Services & Repositories

```java
// Domain: OrderRepository.java
package com.acme.orders.domain;

public interface OrderRepository {
    Optional<Order> findById(OrderId id);
    void save(Order order);
}
```

```java
// Domain: OrderService.java
package com.acme.orders.domain;

public class OrderService {
    private final OrderRepository repo;

    public OrderService(OrderRepository repo) {
        this.repo = repo;
    }

    public void addItemToOrder(OrderId orderId, ProductId productId, int qty) {
        Order order = repo.findById(orderId).orElseThrow(...);
        order.addItem(productId, qty);
        repo.save(order);
    }
}
```

- **Domain services** contain orchestration logic that doesn't belong to a single aggregate.
- The **repository interface** is *in the domain*; implementation resides in infrastructure.

### 4.4  Adapters

#### 4.4.1 Persistence Adapter (e.g., JPA)

```java
// Infrastructure: JpaOrderRepository.java
package com.acme.orders.infrastructure.persistence;

@Repository
public class JpaOrderRepository implements OrderRepository {
    private final JpaRepository<OrderEntity, UUID> jpa;

    @Override
    public Optional<Order> findById(OrderId id) {
        return jpa.findById(id.getUuid()).map(this::toDomain);
    }

    @Override
    public void save(Order order) {
        jpa.save(toEntity(order));
    }

    // Map domain objects to entities
}
```

#### 4.4.2 Messaging Adapter (Kafka)

```java
// Infrastructure: OrderEventPublisher.java
package com.acme.orders.infrastructure.messaging;

public class OrderEventPublisher implements ApplicationEventPublisher {
    private final KafkaTemplate<String, OrderPlacedEvent> template;

    public void publish(OrderPlacedEvent ev) {
        template.send("order-placed", ev.getOrderId().toString(), ev);
    }
}
```

### 4.5  Controller (Adapter)

```java
// Application: OrderController.java
package com.acme.orders.adapter.in.web;

@RestController
@RequestMapping("/orders")
@RequiredArgsConstructor
public class OrderController {
    private final OrderService service;

    @PostMapping("/{id}/items")
    public ResponseEntity<Void> addItem(@PathVariable UUID id,
                                        @RequestBody AddItemDTO dto) {
        service.addItemToOrder(OrderId.of(id), ProductId.of(dto.getProductId()), dto.getQty());
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{id}/place")
    public ResponseEntity<Void> place(@PathVariable UUID id) {
        service.place(OrderId.of(id));
        // after placing, publish event
        eventPublisher.publish(new OrderPlacedEvent(id));
        return ResponseEntity.ok().build();
    }
}
```

- The controller is a *thin* adapter that just delegates to the **application layer** (business service).

### 4.6  Wire Everything in Spring Boot

```java
@Configuration
public class SpringConfiguration {

    @Bean
    public OrderRepository orderRepository(JpaOrderRepositoryImpl impl) {
        return impl; // implements domain interface
    }

    @Bean
    public OrderService orderService(OrderRepository repo) {
        return new OrderService(repo);
    }
}
```

> **Why this matters** – If you later switch from JPA to MongoDB, you only change the **infrastructure** part; the domain remains untouched.

### 4.7  Event‑Driven Flow

- After `order.place(...)`, publish a domain event:  
  `OrderPlacedEvent(order.getId(), order.getTotal(), ...)`.
- Kafka producer emits the event.
- Separate **read‑model** microservices (e.g., Inventory, Analytics) consume the event.

### 4.8  Testing Strategy

| **Test Level** | **Focus** | **Why** |
|----------------|-----------|----------|
| **Unit (Domain)** | `Order` aggregate behavior | Pure domain logic – fast, no external deps |
| **Unit (Application)** | `OrderService` orchestrates repo & domain service | Test orchestration logic |
| **Integration (Adapter)** | JPA repository + DB | Ensure persistence mapping |
| **Integration (Messaging)** | Kafka consumer + producer | End‑to‑end event flow |

> **Tip** – Use *Mockito* (or *Moq* in .NET) to mock repositories and event publishers when unit‑testing domain services.

### 4.9  Deployment & Scaling

- Package as **Docker** container.
- Deploy to Kubernetes or a serverless environment (OpenFaaS, Knative).
- Each microservice can be scaled independently: if the *Order* service experiences traffic spikes, you can spin up more replicas without affecting other services.

---

## 5. Summary (Quick‑Reference)

| **Topic** | **Key Idea** | **Effect on Architecture** |
|-----------|--------------|---------------------------|
| **Domain‑Driven Design** | Bounded Context, Aggregates, Domain Services | Clear separation, easier maintenance |
| **Microservice** | Single bounded context, autonomous | Independent scaling & deployment |
| **Business Service** | Orchestrates domain objects; stateless | Keeps domain logic clean; simplifies testing |
| **Business Adapter** | Thin layer (REST/Kafka) | Allows switching of technology stack without touching domain |
| **Event‑Driven Flow** | Publish/Subscribe on domain events | Decouples read/write models; resilient |
| **Testing** | Unit on domain + adapters + integration | Faster feedback, robust system |

By keeping **domain logic** in its own boundary and treating **business services** as thin adapters that orchestrate aggregates, your microservices will be robust, testable, and ready to evolve as your system grows.  

Feel free to ask follow‑up questions on any specific point—happy to dive deeper!
